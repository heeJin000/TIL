# 자료구조
[![자료구조](https://img.youtube.com/vi/bj2F0hTiTtw/0.jpg)](https://youtube.com/playlist?list=PLuHgQVnccGMDsWOOn_P0EmAWB8DArS3Fk)
<br>
**생활코딩 Data Structure** 를 정리했습니다.
<br><br><br>

## 목차
- [데이터 스트럭쳐란?](https://github.com/heeJin000/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B3%90%EB%9E%80)
- [배열](https://github.com/heeJin000/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md#%EB%B0%B0%EC%97%B4)
  + [List](https://github.com/heeJin000/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md#list)
  + [Array List](https://github.com/heeJin000/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md#array-list)
<br><br><br><br>

# 데이터 스트럭쳐란?
- 현실을 프로그래밍적으로 표현하는 것
  + Tree   ex) 조직도, 디렉토리  
  + Set    한국어로는 집합 ex) 벤다이어그램
  + Graph  ex) 최단 거리 이동 방법
- 거대한 데이터를 효과적으로 관리하는 것
  + 프로그래밍의 도약점은 정리정돈의 진화라고 볼 수 있다.  
  문서 한 장 ▸ 책장 ▸ 도서관 ▸ ... ▸ 인터넷, 네트워크
  + 데이터가 많아지면서 많아진 데이터를 효율적으로 관리하기 위한 복합적인 시스템을 구축하는 게
  데이터 스트럭쳐가 추구하는 목적
<br><br><br><br>

# 배열
- 여러 데이터를 하나의 이름으로 그룹핑해서 관리하기 위한 데이터 스트럭쳐
- 거의 모든 언어에서 지원
- 많은 데이터 스트럭쳐들의 부품
- ex) 

|student|배열 생성|
|--|--|
|student[0]|김길동|
|student[1]|남길동|
|student[2]|도길동|
  + 이름은 value
  + [0][1][2]는 index
  + 'student[0] 김길동' 은 element
<br>

## 반복
- 배열에 저장된 값들을 하나 하나 꺼내 그 각각의 값들의 처리를 할 수 있게 함
<br>

## 자바의 배열
```
int[] number1 = new int[4];
```

- int: 엘리먼트의 데이터 타입
- []: 배열임을 표시
- [4]: 배열의 크기

ex)

```
• 배열 생성
numbers1[0] = 10;
numbers1[1] = 20;
numbers1[2] = 30;
```
|10|20|30|0|
|--|--|--|--|
|[0]|[1]|[2]|[3]

[numbers1 배열]

- 간략한 버전

``` 
int[] number2 = {10, 20, 30, 40};
int[] number3 = new int[]{10, 20, 30, 40};
```

<br><br>

### 배열 값 가져오기

|10|20|30|0|
|--|--|--|--|
|[0]|[1]|[2]|[3]

- 출력 ➡️ System.out.println(number1[3]);
- 배열을 [2]까지만 만들었기 때문에 [3]부터는 빈 값(null). 하지만 출력하면 0이 나온다.
<br>

### 배열의 크기
- numbers1.**length**
- 크기 셀 때는 1부터
- 자바의 배열 크기는 설정한 값들의 갯수가 아니라 배열을 구성하고 있는 엘리먼트 갯수
  (numbers1은 값을 세 개만 주었기 때문에 length를 출력하면 3이 나옴)
<br>

### 반복
```
int i = 0;
while(numbers1.length > i ){
    System.out.println(numbers1[i]);
    i++;
}
```

[while문]
- 단점
  + int i 를 초기 값 지정, 반복 조건 지정, i 증가가 흩어져있음 ▸ 그 사이에 다른 코드가 끼어들 위험이 있음 (버그 위험)


```
for(int i = 0; numbers1.length > i; i++){
    System.out.println(numbers1[i]);
}
```

[for문]
<br><br>

## 배열의 장단점
- 장단점
  + 크기가 정해져 있음(처음 지정한 크기 보다 더 많은 정보를 넣을 수 없음)
  + 기능이 없음

- 작고 가볍고 단순한 매력
  ➡️ 배열은 데이터 스트럭쳐의 좋은 부품
<br><br><br><br>

# List
## List 특징
- 순서대로 저장
- 데이터 중복 허용
<br>

## Array VS List
- Array
  + 몇 동 몇 호 정확한 인덱스
  + 생성: 새로운 데이터가 기존 데이터를 덮어버림  
  ex) [3]30 인데 [3]에 40을 넣으려고 하면 40이 30을 덮어버림
  + 삭제: 데이터를 삭제하면 인덱스는 남아서 빈 자리가 됨

- List
  + 홍길동 - 김길동 - 정길동 같은 데이터 간 순서가 중요
  + 생성: 새로운 데이터가 기존 데이터를 뒤로 밀어냄  
  ex) [3]30 인데 [3]에 40을 넣으려고 하면 30은 [4]로 가고 [3]40이 됨
  ➡️ [4]가 새로 생김!
  + 삭제: 데이터를 삭제하면 인덱스도 삭제되고 뒤에 있던 엘리먼트들이 하나씩 앞으로 땡겨짐

  | |Array|List|
  |--|--|--|
  |장점|인덱스-메모리에 변경이 없음|빈자리 확인하지 않아도 됨|
  |단점|빈자리를 확인해야 함, 빈 공간 때문에 메모리를 낭비|인덱스-메모리에 변경이 있음|

<br>

## List 기능
- 처음, 끝, 중간에 엘리먼트를 추가/삭제하는 기능
- List에 데이터가 있는지 체크
- List의 모든 데이터에 접근
<br>

## 언어별 비교
- C: List 지원 안 함(배열 사용)
- JavaScript: 배열이 List
```
numbers = [10, 20, 30, 40, 50];
numbers.splice(3,1); // 인덱스 3인 데이터부터 하나. 50이 앞으로 땡겨짐
for(i=0;i<numbers.length;i++){
    console.log(numbers[i]);
}
```

- python: List가 배열
```
numbers = [10, 20, 30, 40, 50];
numbers.pop(3); # 인덱스 3의 데이터 삭제. 50은 앞으로 땡겨짐
for number in numbers:
  print(number);
```

- Java: 배열, List 모두 지원 / 분리됨
```
//배열
int[] numbers = {10, 20, 30, 40, 50};

// List
ArrayList numbers = new ArrayList();
numbers.add(10);
numbers.add(20);
numbers.add(30);
...
numbers.remove(3);
```
❗️ Java는 List가 두 종류
```
LinkedList numbers = new LinkdedList();
ArrayList numbers = new ArrayList();
```

| |추가/삭제|인덱스 조회|
|--|--|--|
|ArrayList|느림|빠름|
|LinkedList|빠름|느림|

➡️ 복잡하지만 자유도 높음

❗️ **데이터 스트럭쳐는 언어마다 다르다**

<br><br><br><br>

# Array List


## 데이터 삽입 / 삭제
### Insert 데이터 삽입

|10|20|30|40|
|--|--|--|--|
|0|1|2|3|

*1번 인덱스에 50을 넣으려 한다면?*
<br>

1. 인덱스 4를 만들어 40부터 순차적으로 뒤로 옮김
2. 1번 인덱스가 비면 50을 그곳에 넣음

### Delete 데이터 삭제

|10|20|30|40|50|
|--|--|--|--|--|
|0|1|2|3|4|

*30을 없앤다면?*
<br>

1. 30을 삭제
2. 빈공간이 생김
3. 인덱스 3부터 앞으로 이동(인덱스는 n-1이 됨)
<br>
➡️ 하나씩 앞으로 뒤로 땡기고 옮기고... 시간이 많이 소요
<br>

## Get 가져오기
- 인덱스 값을 알고 있어서 그 인덱스 값으로 데이터를 가져옴
  + ex) 4015호 ➡️ 4번 건물에 15층이네 / 호수 몰랐다면? 건물 모두 뒤져야 함
  + 호수를 정확히 알고 찾는 것이 Array List(빠름) / 건물 모두 뒤지는게 Linked List(느림)
<br>

## Size 크기
|10|20|30|40|
|--|--|--|--|
|0|1|2|3|

- Array List는 내부적으로 사이즈라는 변수를 유지
- 데이터 추가하면 사이즈 1올리고 삭제하면 1 내리며 값을 유지  
  ➡️ 변수값(Size)을 통해 몇 개의 엘리먼트가 List 안에 있는지 알아낼 수 있음
<br><br><br><br>

# Array List 자바 구현
## 객체 생성

- Main.java
```
package list.arraylist.implementation;
public class Main{
    public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40);

        // 데이터가 끝에서 추가
        
    }
}
```

- ArrayList.java
```
package list.arraylist.implementation;
public class ArrayList(){
    private int size = 0; // 현재 ArrayList 안에 데이터 몇 개?
    private Object[] elementData = new Object[100]; // 100개의 데이터를 담는 Object 타입의 배열 생성

    public boolean addLast(Object element){
        elementData[size] = element; // elementData 배열의 size번째 값은 element
        size++; // size가 1씩 증가

        return true;
    }
}
```
|10|20|30|40|
|--|--|--|--|
|0|1|2|3|

결과적으로 elementData 배열에 10 ~ 40이 순차적으로 쌓임
<br><br>

*만약 10과 20 사이에 15를 넣고 싶다면?*  
- 1번 인덱스에 15가 들어가고 그 뒤에 20오고 쭉쭉 뒤로 한 칸씩 밀리겠지?  
➡️ 4번 인덱스가 생기고 맨 뒤에 있는 40이 4번 인덱스로 30이 3번 인덱스로... 현상이 일어남
- 데이터를 특정한 위치에 끼워넣고 싶다면 모든 element를 한 칸씩 뒤로 땡겨주어야 함(=해야 할 일이 많다)  
- element가 100000개 라면? 너무 오래 걸림

```
package list.arraylist.implementation;
public class Main{
    public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40);
        numbers.add(1, 15); // index 1번에 15를 추가
        numbers.addFirst(5); // numbers 첫번째 위치에 5를 넣는 메소드     
        
    }
}
```

```
package list.arraylist.implementation;
public class ArrayList(){
    private int size = 0; // 현재 ArrayList 안에 데이터 몇 개?
    private Object[] elementData = new Object[100]; // 100개의 데이터를 담는 Object 타입의 배열 생성

    public boolean addLast(Object element){
        elementData[size] = element; // elementData 배열의 size번째 값은 element
        size++; // size가 1씩 증가

        return true;
    }

    // add 메소드
    public boolean add(int index, Object element){
        for(int i = size - 1; i >= index; i--){
            elementData[i + 1] = elementData[i];
        }
        elementData[index] = element;
        size++;
        return true;
    }

    // addFirst 메소드
    public boolean addFirst(Object element){

        return add(0, element); // 첫번째 자리에 element를 넣으면서 
        // 한 칸씩 뒤로 미루는 add() 고유 작업도 가능
    }

}
```


```
// 뒤로 한 칸씩 밀기 코드로 구현
elementData[4] = elementData[3]; //3은 size -1
elementData[3] = elementData[2];
elementData[2] = elementData[1]; // 1은 index

// add() 처럼 반복문을 이용하는 게 좋음
```




  

