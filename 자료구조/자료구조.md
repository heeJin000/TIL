# 자료구조
[![자료구조](https://img.youtube.com/vi/bj2F0hTiTtw/0.jpg)](https://youtube.com/playlist?list=PLuHgQVnccGMDsWOOn_P0EmAWB8DArS3Fk)
<br>
**생활코딩 Data Structure** 를 정리했습니다.
<br><br><br>

## 목차
- [데이터 스트럭쳐란?](https://github.com/heeJin000/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B3%90%EB%9E%80)
- [배열](https://github.com/heeJin000/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md#%EB%B0%B0%EC%97%B4)
  + [List](https://github.com/heeJin000/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md#list)
  + [Array List](https://github.com/heeJin000/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md#array-list)
  + [Linked List](https://github.com/heeJin000/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md#linked-list)
  + [Java와 Linked List](https://github.com/heeJin000/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md#java%EC%97%90%EC%84%9C-linked-list-%EA%B5%AC%ED%98%84)
<br><br><br><br>

# 데이터 스트럭쳐란?
- 현실을 프로그래밍적으로 표현하는 것
  + Tree   ex) 조직도, 디렉토리  
  + Set    한국어로는 집합 ex) 벤다이어그램
  + Graph  ex) 최단 거리 이동 방법
- 거대한 데이터를 효과적으로 관리하는 것
  + 프로그래밍의 도약점은 정리정돈의 진화라고 볼 수 있다.  
  문서 한 장 ▸ 책장 ▸ 도서관 ▸ ... ▸ 인터넷, 네트워크
  + 데이터가 많아지면서 많아진 데이터를 효율적으로 관리하기 위한 복합적인 시스템을 구축하는 게
  데이터 스트럭쳐가 추구하는 목적
<br><br><br><br>

# 배열
- 여러 데이터를 하나의 이름으로 그룹핑해서 관리하기 위한 데이터 스트럭쳐
- 거의 모든 언어에서 지원
- 많은 데이터 스트럭쳐들의 부품  
- ex) 

|student|배열 생성|
|--|--|
|student[0]|김길동|
|student[1]|남길동|
|student[2]|도길동|
  + 이름은 value
  + [0][1][2]는 index
  + 'student[0] 김길동' 은 element
<br>

## 반복
- 배열에 저장된 값들을 하나 하나 꺼내 그 각각의 값들의 처리를 할 수 있게 함
<br>

## 자바의 배열
```
int[] number1 = new int[4];
```

- int: 엘리먼트의 데이터 타입
- []: 배열임을 표시
- [4]: 배열의 크기

ex)

```
• 배열 생성
numbers1[0] = 10;
numbers1[1] = 20;
numbers1[2] = 30;
```
|10|20|30|0|
|--|--|--|--|
|[0]|[1]|[2]|[3]

[numbers1 배열]

- 간략한 버전

``` 
int[] number2 = {10, 20, 30, 40};
int[] number3 = new int[]{10, 20, 30, 40};
```

<br><br>

### 배열 값 가져오기

|10|20|30|0|
|--|--|--|--|
|[0]|[1]|[2]|[3]

- 출력 ➡️ System.out.println(number1[3]);
- 배열을 [2]까지만 만들었기 때문에 [3]부터는 빈 값(null). 하지만 출력하면 0이 나온다.
<br>

### 배열의 크기
- numbers1.**length**
- 크기 셀 때는 1부터
- 자바의 배열 크기는 설정한 값들의 갯수가 아니라 배열을 구성하고 있는 엘리먼트 갯수
  (numbers1은 값을 세 개만 주었기 때문에 length를 출력하면 3이 나옴)
<br>

### 반복
```
int i = 0;
while(numbers1.length > i ){
    System.out.println(numbers1[i]);
    i++;
}
```

[while문]
- 단점
  + int i 를 초기 값 지정, 반복 조건 지정, i 증가가 흩어져있음 ▸ 그 사이에 다른 코드가 끼어들 위험이 있음 (버그 위험)


```
for(int i = 0; numbers1.length > i; i++){
    System.out.println(numbers1[i]);
}
```

[for문]
<br><br>

## 배열의 장단점
- 장단점
  + 크기가 정해져 있음(처음 지정한 크기 보다 더 많은 정보를 넣을 수 없음)
  + 기능이 없음

- 작고 가볍고 단순한 매력
  ➡️ 배열은 데이터 스트럭쳐의 좋은 부품
<br><br><br><br>

# List
## List 특징
- 순서대로 저장
- 데이터 중복 허용
<br>

## Array VS List
- Array
  + 몇 동 몇 호 정확한 인덱스
  + 생성: 새로운 데이터가 기존 데이터를 덮어버림  
  ex) [3]30 인데 [3]에 40을 넣으려고 하면 40이 30을 덮어버림
  + 삭제: 데이터를 삭제하면 인덱스는 남아서 빈 자리가 됨

- List
  + 홍길동 - 김길동 - 정길동 같은 데이터 간 순서가 중요
  + 생성: 새로운 데이터가 기존 데이터를 뒤로 밀어냄  
  ex) [3]30 인데 [3]에 40을 넣으려고 하면 30은 [4]로 가고 [3]40이 됨
  ➡️ [4]가 새로 생김!
  + 삭제: 데이터를 삭제하면 인덱스도 삭제되고 뒤에 있던 엘리먼트들이 하나씩 앞으로 땡겨짐

  | |Array|List|
  |--|--|--|
  |장점|인덱스-메모리에 변경이 없음|빈자리 확인하지 않아도 됨|
  |단점|빈자리를 확인해야 함, 빈 공간 때문에 메모리를 낭비|인덱스-메모리에 변경이 있음|

<br>

## List 기능
- 처음, 끝, 중간에 엘리먼트를 추가/삭제하는 기능
- List에 데이터가 있는지 체크
- List의 모든 데이터에 접근
<br>

## 언어별 비교
- C: List 지원 안 함(배열 사용)
- JavaScript: 배열이 List
```
numbers = [10, 20, 30, 40, 50];
numbers.splice(3,1); // 인덱스 3인 데이터부터 하나. 50이 앞으로 땡겨짐
for(i=0;i<numbers.length;i++){
    console.log(numbers[i]);
}
```

- python: List가 배열
```
numbers = [10, 20, 30, 40, 50];
numbers.pop(3); # 인덱스 3의 데이터 삭제. 50은 앞으로 땡겨짐
for number in numbers:
  print(number);
```

- Java: 배열, List 모두 지원 / 분리됨
```
//배열
int[] numbers = {10, 20, 30, 40, 50};

// List
ArrayList numbers = new ArrayList();
numbers.add(10);
numbers.add(20);
numbers.add(30);
...
numbers.remove(3);
```
❗️ Java는 List가 두 종류
```
LinkedList numbers = new LinkdedList();
ArrayList numbers = new ArrayList();
```

| |추가/삭제|인덱스 조회|
|--|--|--|
|ArrayList|느림|빠름|
|LinkedList|빠름|느림|

➡️ 복잡하지만 자유도 높음

❗️ **데이터 스트럭쳐는 언어마다 다르다**

<br><br><br><br>

# Array List


## 데이터 삽입 / 삭제
### Insert 데이터 삽입

|10|20|30|40|
|--|--|--|--|
|0|1|2|3|

*1번 인덱스에 50을 넣으려 한다면?*
<br>

1. 인덱스 4를 만들어 40부터 순차적으로 뒤로 옮김
2. 1번 인덱스가 비면 50을 그곳에 넣음

### Delete 데이터 삭제

|10|20|30|40|50|
|--|--|--|--|--|
|0|1|2|3|4|

*30을 없앤다면?*
<br>

1. 30을 삭제
2. 빈공간이 생김
3. 인덱스 3부터 앞으로 이동(인덱스는 n-1이 됨)
<br>
➡️ 하나씩 앞으로 뒤로 땡기고 옮기고... 시간이 많이 소요
<br>

## Get 가져오기
- 인덱스 값을 알고 있어서 그 인덱스 값으로 데이터를 가져옴
  + ex) 4015호 ➡️ 4번 건물에 15층이네 / 호수 몰랐다면? 건물 모두 뒤져야 함
  + 호수를 정확히 알고 찾는 것이 Array List(빠름) / 건물 모두 뒤지는게 Linked List(느림)
<br>

## Size 크기
|10|20|30|40|
|--|--|--|--|
|0|1|2|3|

- Array List는 내부적으로 사이즈라는 변수를 유지
- 데이터 추가하면 사이즈 1올리고 삭제하면 1 내리며 값을 유지  
  ➡️ 변수값(Size)을 통해 몇 개의 엘리먼트가 List 안에 있는지 알아낼 수 있음
<br><br><br><br>

# Array List 자바 구현
## 객체 생성

- Main.java
```
package list.arraylist.implementation;
public class Main{
    public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40);

        // 데이터가 끝에서 추가
        
    }
}
```

- ArrayList.java
```
package list.arraylist.implementation;
public class ArrayList(){
    private int size = 0; // 현재 ArrayList 안에 데이터 몇 개?
    private Object[] elementData = new Object[100]; // 100개의 데이터를 담는 Object 타입의 배열 생성

    public boolean addLast(Object element){
        elementData[size] = element; // elementData 배열의 size번째 값은 element
        size++; // size가 1씩 증가

        return true;
    }
}
```
|10|20|30|40|
|--|--|--|--|
|0|1|2|3|

결과적으로 elementData 배열에 10 ~ 40이 순차적으로 쌓임
<br><br>

*만약 10과 20 사이에 15를 넣고 싶다면?*  
- 1번 인덱스에 15가 들어가고 그 뒤에 20오고 쭉쭉 뒤로 한 칸씩 밀리겠지?  
➡️ 4번 인덱스가 생기고 맨 뒤에 있는 40이 4번 인덱스로 30이 3번 인덱스로... 현상이 일어남
- 데이터를 특정한 위치에 끼워넣고 싶다면 모든 element를 한 칸씩 뒤로 땡겨주어야 함(=해야 할 일이 많다)  
- element가 100000개 라면? 너무 오래 걸림

```
package list.arraylist.implementation;
public class Main{
    public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40);
        numbers.add(1, 15); // index 1번에 15를 추가
        numbers.addFirst(5); // numbers 첫번째 위치에 5를 넣는 메소드     
        
    }
}
```

```
package list.arraylist.implementation;
public class ArrayList(){
    private int size = 0; // 현재 ArrayList 안에 데이터 몇 개?
    private Object[] elementData = new Object[100]; // 100개의 데이터를 담는 Object 타입의 배열 생성

    public boolean addLast(Object element){
        elementData[size] = element; // elementData 배열의 size번째 값은 element
        size++; // size가 1씩 증가

        return true;
    }

    // add 메소드
    public boolean add(int index, Object element){
        for(int i = size - 1; i >= index; i--){
            elementData[i + 1] = elementData[i];
        }
        elementData[index] = element;
        size++;
        return true;
    }

    // addFirst 메소드
    public boolean addFirst(Object element){

        return add(0, element); // 첫번째 자리에 element를 넣으면서 
        // 한 칸씩 뒤로 미루는 add() 고유 작업도 가능
    }

}
```


```
// 뒤로 한 칸씩 밀기 코드로 구현
elementData[4] = elementData[3]; //3은 size -1
elementData[3] = elementData[2];
elementData[2] = elementData[1]; // 1은 index

// add() 처럼 반복문을 이용하는 게 좋음
```

## toString
### toString() 적용 전

```
package list.arraylist.implementation;
public class Main{
    public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 
        numbers.add(1, 15); 
        numbers.addFirst(5);    

        System.out.println(numbers);
        
    }
}
```

```
[console]

list.arraylist.implementation.ArrayList@14db9852

```
▸ 객체가 위치한 곳, 레퍼런스 값을 출력

<br>

### 레퍼런스 말고 값 자체를 보고 싶다
- Java에서 지원하는 toString()을 이용

```
main 생략
```

```
package list.arraylist.implementation;
public class ArrayList(){
    private int size = 0; 
    private Object[] elementData = new Object[100]; 

    public boolean addLast(Object element){
        elementData[size] = element; 
        size++; 

        return true;
    }

    // add 메소드
    public boolean add(int index, Object element){
        for(int i = size - 1; i >= index; i--){
            elementData[i + 1] = elementData[i];
        }
        elementData[index] = element;
        size++;
        return true;
    }

    // addFirst 메소드
    public boolean addFirst(Object element){

        return add(0, element); 
        
    }

    public String toString(){
        return "TEST";
    }

}
```

```
[console]
TEST
```
➡️ main의 System.out.println(numbers);에서 toString() 값이 출력  
<br>
▸ toString()을 직접 구현하면 객체를 문자로 출력해야 하는 상황에서  toString()이라는 약속된 이름을 가진 메소드가 호출되도록 정해져있음  
<br>

- toString() 수정
```
...
...
public String toString(){
    String str = "[";
    for(int i = 0; i < size; i++){
        str += elementData[i];

        // 마지막 , 제외 
        if(i < size-1){
            srt += ",";
        }      
    }
    return str + "]";
}

```

```
[console]
[5, 10, 15, 20, 30, 40]
```
<br><br><br><br>

## remove

*배열 값을 삭제해보자*

- 원리

|10| |20|30|40|
|--|--|--|--|--|
|0| |2|3|4|

<br>
  
  + 빈 자리가 생기면 오른쪽에 있는 엘리먼트가 빈 자리로 이동하려 함
  + add와 반대 방향



```
package list.arraylist.implementation;
public class Main{
    public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        ...
        numbers.add(20);
        ...        
        numbers.addFirst(5);         

        System.out.println(numbers.remove(1)); // 1번 인덱스 삭제        
        System.out.println(numbers); // numbers 배열 출력
        
    }
}
```

```
package list.arraylist.implementation;
public class ArrayList(){

// 생략

public String toString(){
    String str = "[";
    for(int i = 0; i < size; i++){
        str += elementData[i];

        // 마지막 , 제외 
        if(i < size-1){
            srt += ",";
        }      
    }
    return str + "]";
}

public Object remove(int index){
    Object removed = elementData[index]; // 삭제하려고 하는 데이터 값 기록
    for(int i =index+1; i <= size-1; i++){
        elementData[i - 1] = elementData[i];
    }
    size--;
    elementData[size] = null;
    return removed; // 어떤 것을 삭제했는지 반환
 }
}

```

```
[console]
20
[10, 30, 40]
```

- 데이터 삭제마다 재조정 ➡️ 느리다
<br><br><br><br>

## removeFirst, removeLast

```
package list.arraylist.implementation;
public class ArrayList(){

// 생략

public Object remove(int index){
    Object removed = elementData[index]; // 삭제하려고 하는 데이터 값 기록
    for(int i =index+1; i <= size-1; i++){
        elementData[i - 1] = elementData[i];
    }
    size--;
    elementData[size] = null;
    return removed; // 어떤 것을 삭제했는지 반환
 }

 public Object removeFirst(){
     return remove(0);
 }

public Object removeLast(){
    return(size-1);
}

}
```


```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 
        numbers.removeFirst();
        numbers.removeLast();

    System.out.println(numbers);
    }
}
```

```
[console]
[20, 30]
```

<br><br><br><br>

## get
- 특정 인덱스에 있는 element를 가져오는 자바의 메소드
```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 

    System.out.println(numbers.get(1));   
    }
}
```

```
package list.arraylist.implementation;
public class ArrayList(){

// 생략

public Object removeLast(){
    return(size-1);
}

public Object get(int index){
    return elementData[index];
}

}
```

```
[console]
20
```

- 배열의 인덱스로 접근한다는 장점이 생김
  + 메모리는 RAM을 이용해 어느 위치의 데이터를 가져오건 동일한 시간이 걸림 
  + ArrayList는 get을 통한 특정한 위치의 데이터를 가져오는 게 아주 빠름
  <br><br><br><br>

## size
- 외부에서 size 변수의 수정을 막기 위해 메소드로 값을 반환(size 변수는 private로 정의되어있음)

```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 

    System.out.println(numbers.size());   
    }
}
```

```
package list.arraylist.implementation;
public class ArrayList(){

// 생략

public Object removeLast(){
    return(size-1);
}

public Object get(int index){
    return elementData[index];
}

public int size(){
    return size;
}

}
```

```
[console]
4
```

<br><br><br><br>

## indexOf
- 특정 값의 인덱스를 반환
- 인덱스를 돌며 해당 값이 있는지 없는지 찾는다
```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 

    System.out.println(numbers.indexOf(20));   
    }
}
```

```
package list.arraylist.implementation;
public class ArrayList(){

// 생략

public int indexOf(Object o){
    for(int i = 0; i < size; i++){
        if(o.equals(felementData[i])){
            return i;
        }
    }

    return -1; // 찾는 값이 없다
}

}
```

<br><br><br><br>

## iterator next hasNext
- List의 반복적인 일을 처리

### for문
```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 

    for(int i = 0; i < numbers.size(); i++){
        System.out.println(numbers.get(i));
    }  
    }
}
```

```
[console]
10
20
30
40
```
<br>

### next()

```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 

    ArrayList.ListIterator li = numbers.listIterator(); // 객체를 리턴하는 메소드
    System.out.println(li.next());

    }
}
```
▸ li의 데이터 타입은 ArrayList 내부의 또 다른 클래스 ListIterator

```
package list.arraylist.implementation;
public class ArrayList(){
    private int size = 0;
    private Object[] elementData = new Object[100];

// 생략

public ListIterator listIterator(){

    return new ListIterator();
}

class ListIterator{
    private int nextIndex = 0;

    public Object next(){
        Object returnData = elementData[nextIndex]; 
        nextIndex++;
        return returnData;
    }

}

}
```

### iterator
- 반복적인 작업을 위해 만들어진 객체
```
package list.arraylist.implementation;
public class ArrayList(){
    private int size = 0;
    private Object[] elementData = new Object[100];

// 생략

public ListIterator listIterator(){

    return new ListIterator();
}

class ListIterator{
    private int nextIndex = 0;

    public Object next(){
        
        return elementData[nextIndex++]; // 더 짧지만 같은 일을 수행
    }

}

}
```


```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 

    ArrayList.ListIterator li = numbers.listIterator(); 
    System.out.println(li.next());
    System.out.println(li.next());
    System.out.println(li.next());
    System.out.println(li.next());
    System.out.println(li.next());
    System.out.println(li.next()); // while 사용 안 한 Ver.

    

    }
}
```

```
[console]
10
20
30
40
null
null
```
- elementData[]에 들어있는 element까지만 출력하고 그 뒤로는 null을 출력함

```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 

    ArrayList.ListIterator li = numbers.listIterator(); 
    
    // while Ver.
    while(true){ 
        System.out.println(li.next()); 
     }    
  }
}
```

```
[console]
...
null
null
null
Exception in thread "main" java.lang.ArrayIndexOut...
```

- elementData[]의 최대 크기인 100을 넘어서면서 에러 발생
- 100이 되면 멈추게 해야 함

### hasNext()
- nextIndex와 size를 비교 ➡️ nextIndex가 size보다 커지기 전 반복이 종료
```
package list.arraylist.implementation;
public class ArrayList(){
    private int size = 0;
    private Object[] elementData = new Object[100];

// 생략

public ListIterator listIterator(){

    return new ListIterator();
}

class ListIterator{
    private int nextIndex = 0;

    public boolean hasNext(){
        return nextIndex < size();
    }

    public Object next(){
        
        return elementData[nextIndex++]; // 더 짧지만 같은 일을 수행
    }

}

}
```

```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 

    ArrayList.ListIterator li = numbers.listIterator(); 
    
    
    while(li.hasNext()){ 
        System.out.println(li.next()); 
     }    
  }
}
```

```
[console]
10
20
30
40
```

### previous / hasPrevious
- 이전 인덱스의 값을 출력

#### previous

```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 

    ArrayList.ListIterator li = numbers.listIterator(); 
    li.next(); // 10
    li.next(); // 20
    li.next(); // 30
    li.next(); // 40   
    li.previous(); //40 이전, 즉 30
    li.previous(); // 20
    li.previous(); // 10
    li.previous(); // java.lang.ArrayIndexOutOfBoundsException
  }
}
```

```
package list.arraylist.implementation;
public class ArrayList(){
    private int size = 0;
    private Object[] elementData = new Object[100];

// 생략

public Object previous(){
    return elementData[--nextIndex];
}

}

}
```

- 0번 인덱스에서 멈추지 않으면 OutOfBoundsException
- hasNext처럼 0번 인덱스에서 멈추는 메소드가 필요
<br>

#### hasPrevious
```
package list.arraylist.implementation;
public class ArrayList(){
    private int size = 0;
    private Object[] elementData = new Object[100];

// 생략

public boolean hasPrevious(){
    return nextIndex > 0;
}

}

}
```

```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 

    ArrayList.ListIterator li = numbers.listIterator(); 
    while(li.hasNext()){ 
        System.out.println(li.next()); 
     } 

    while(li.hasPrevious()){ 
        System.out.println(li.previous()); 
     } 

  }
}
```
<br><br><br><br>

### Iterator add remove
#### add

```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 

    ArrayList.ListIterator li = numbers.listIterator(); 
    while(li.hasNext()){ 
        int number = (int)li.next(); // li는 Object 타입이므로 int 형변환

        if(number == 30){
            li.add(35);
        }
     } 
        System.out.println(number);

  }
}
```
element 값으로 30을 만나면 그 뒤에 35를 추가

```
package list.arraylist.implementation;
public class ArrayList(){
    private int size = 0;
    private Object[] elementData = new Object[100];

// 생략

public void add(Object element){
    ArrayList.this.add(nextIndex++, element); // this로 확실하게
}
}

}

}
```
기존에 있는 add()를 재사용한다. 이 때 이름이 같아 충돌이 발생하므로 ArrayList.this.add()로 명시한다.

```
[console]
[10, 20, 30, 35, 40]
```

### Iterator add remove
#### add
```
package list.arraylist.implementation;
public class Main{
     public static void main(String[] args){
        ArrayList numbers = new ArrayList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        numbers.addLast(40); 

    ArrayList.ListIterator li = numbers.listIterator(); 
    while(li.hasNext()){ 
        int number = (int)li.next(); // li는 Object 타입이므로 int 형변환

        if(number == 30){
            li.remove(); // 30을 지우겠다.
        }
     } 
        System.out.println(number);

  }
}
```

```
package list.arraylist.implementation;
public class ArrayList(){
    private int size = 0;
    private Object[] elementData = new Object[100];

// 생략

public void remove(){
    ArrayList.this.remove(nextIndex-1);
    nextIndex--;
        }
    }


  }

}
```
<br><br><br><br>

# Linked list

## 데이터 저장과 처리
  + memory: 가격이 비쌈 / 전원 off 데이터 사라짐 / 데이터 전송 속도가 빠름
            ❗️ Data Structure 대상
  + Storage: 가격이 저렴 / 용량이 큼 전원이 off 데이터 저장
             HDD, SDD, 플로피 디스크 
  + CPU: 데이터 처리 속도 셋 중 1등

- CPU가 필요한 데이터를 storage에게 직접 받으면 너무 느림

- storage ➡️ memory ➡️ CPU 
  startage에 있던 데이터를 memory로 옮겨와서 CPU가 처리

### memory
- 건물 동 호수와 비슷
- 각 호수에 접근하는 주소가 가르키는 각각의 위치에 데이터가 저장
- 각각의 주소에 접근하는 걸리는 시간이 동일
- Random Access Memory ➡️ RAM
<br><br>

### Array VS Linked
<img width="560" alt="Array VS Linked" src="https://user-images.githubusercontent.com/86607510/155884887-7b9a0b3e-e327-445b-aff9-3e2273eb2e46.png">

- ArrayList
  + 같은 element들이 메모리 상에서 연속적으로 붙어있음

- LinkedList
  + 흩어져있지만 서로 연결되어있음
  <br><br>

## Linked list의 구조
<img width="560" alt="Linked" src="https://user-images.githubusercontent.com/86607510/155997203-2d9a45a8-5ea4-4f34-bcf1-3e8ca9ef41a3.png">

- 하나하나가 일종의 element
- Link list는 연결하는 특성 갖고있음
- element 대신 "node" 또는 "vertex" 
- node = 마디, 교점 / vertex는 정점, 꼭지점 (둘 다 어떤 연결을 의미)  
   ➡️ c: 구조체  
   ➡️ 객체지향: 객체
- Data field: 실제 저장되는 값을 담는 변수
- Link field: 다음 노드가 무엇인가가 저장되는 변수
- Head: 다음 노드들을 찾아가기 위한 기준인 첫번째 노드에 대한 데이터를 담음. 변수o
 <br><br><br><br>

## Linked list - head에 데이터 추가
*[visualgo](https://visualgo.net/en/list)에서 여러 자료구조를 만들어볼 수 있다.*  
<br><br>
<img width="520" alt="insert node into head" src="https://user-images.githubusercontent.com/86607510/156581354-843d775b-126d-4183-a775-2d698b42047d.jpg">

- 85가 15를 밀어내고 Head를 차지했다. element는 자신 다음 숫자를 가리키고 있다.
- 오른쪽 하단은 어떤 일이 일어났는지 코드 상으로 표현한 의사코드(수도코드).
<br><br><br>

### 단계별로 코드 살피기
85를 head에 삽입하는 의사코드를 한 줄씩 살펴보자    
```
Vertex temp = new Vertex(input)
```
1) new 연산자를 이용해 Vertex의 새로운 객체를 만들었다.  
2) 인자값 input에 85가 들어간다.  
3) 이렇게 생긴 노드의 이름은 temp이고 값은 85를 가진다.  

```
temp.next = head
```
1) 다음 값을 가리키는 next라는 변수가 temp 노드에 내재돼있다.  
   (※ 노드 안 next 덕분에 linked list는 노드가 연결될 수 있다)  
2) next를 기존의 첫번째 노드를 가리키게 하면 됨(여기서는 22가 해당됨)
3) 22는 변수 head 안에 저장되어있다.  

```
head = temp
```
1) 85의 next는 15 head 값은 여전히 15  
2) head가 85 노드를 가리킨다.  
3) list의 첫번째 노드는 85가 된다.  
<br><br><br><br>

## Linked list - 중앙에 데이터 추가
<img width="520" alt="insert node into middle" src="https://user-images.githubusercontent.com/86607510/157045422-81d910f1-f835-43c2-81d6-d37bac2551d0.jpg">

- 80이라는 새로운 노드를 2와 77 노드에 연결한 뒤 그 사이로 넣는다.
- 오른쪽 하단에는 이 과정을 표현한 의사 코드(수도 코드)
<br><br><br>

### 단계별로 코드 살피기
```
Vertex pre = head
for(k = 0; k < i-1; k++)
    pre = pre.next
```
1. 첫번째에 위치한 head 노드를 temp1에 담는다.
2. 두 번째 자리에 삽입을 할 것이기 때문에 i를 2로 설정한다. ([여기](https://user-images.githubusercontent.com/86607510/157459927-c23068d8-f476-47c4-b8c1-4b582a04607a.jpg)서 확인할 수 있다.)  
   이 때 pre의 다음 값이 pre에 담기도록 만든다.
3. pre의 값은 2가 되고 k는 1이 된다. 제어문이 거짓이 되어 반복이 종료된다.

```
Vertex aft = pre.next
Vertext vtx = new Vertex(v)
```
1. 현재 pre의 값인 2의 다음 노드인 77이 aft에 담긴다.
2. new Vertex로 새로운 노드를 만든다. 새로운 노드는 변수 vtx에 담긴다.

```
vtx.next = aft
pre.next = vtx
```
1. aft에 담긴 77이 새로운 노드 다음값이 된다. 즉 새로운 노드가 77 이전에 위치하게 된다.
2. 새로운 노드는 2의 다음 값이 된다.
3. 이 코드들을 수행하면 최종적으로 새로운 노드는 2와 77의 사이에 위치하게 된다.  
<br>
➡️ Linked list: 앞 쪽 뒤 쪽 노드가 서로 무엇을 가리키고 있는지 그 관계만 바꿔주게 되면  
  데이터 추가 작업이 간단히 끝난다.<br>
➡️ Array list: 맨 끝부터 한 칸씩 뒤로 밀어주어야 하기 때문에 느리다.
<br><br><br><br>

## Linked list - 데이터 삭제
<img width="520" src=https://user-images.githubusercontent.com/86607510/158385582-e9abadd4-3c7b-4e9e-b741-b56d17bb078b.gif>
<br><br>

### 단계별로 코드 살피기
```
if empty, do nothing
Vertex pre = head
```
1. 변수 pre에 head를 담는다. pre 안에는 40이 담긴다.

```
for(k=0; k < i-1; k++)
pre = pre.next
```
1. i에는 2가 담겨있다.
2. for문 제어식은 참이고 body 부분이 실행된다.
3. 40을 담던 pre는 pre의 다음 노드인 98을 담게 된다.
4. k는 1이 되면서 for문은 종료된다.

```
Vertex del = pre.next, aft = del.next
pre.next = aft //bypass del
delte del
```
1. del 변수안에 98이 담긴다. 만약에 이 element를 삭제해버린다면  
56이 담긴 노드를 통제할 수 없기 때문에 곧바로 삭제하지 않고  
변수에 담기만 한다. (98을 기준으로 그 옆의 56을 데리고 오기 때문에  
반드시 필요한 작업이다.)
2. 변수 aft는 del의 다음 노드인 56을 담는다. 
3. pre의 다음 노드에 aft가 오게 한다.
4. 쓸모를 다한 del을 삭제한다.


- 각각의 노드가 다음 노드를 알지만 전체 노드는 모르기 때문에 이런 복잡한 과정을 거쳐서 삭제
    ➡️ 다루기 까다롭고 오류날 확률이 높음  
- arrayList와 비교
    + Linked List: 40이 56을 가리키게 하고 98 삭제 (성능 win)
    + Array List: 노드 삭제 후 그 다음 노드부터 순차적으로 앞으로 땡긴다.
    <br><br><br><br>


# Java에서 Linked list 구현

## Collection Framework
- Collection > List > ArrayList, ... , LinkedList
- 사용방법은 비슷하지만 클래스의 내부적인 구현방법이 다름
- ArrayList: 배열 / LinkedList: 객체를 만들고 객체와 객체를 연결(레퍼런스)
- 작업에 따라 적합한 Data Structure를 선택할 줄 알아야 함
<br><br><br><br>



## Linked List 자바 구현
```
☕️ LinkedList.java

package list.linkedlist.implementation;
public class LinkedList{
    private Node head;      // 첫번째 노드
    private Node tail;      // 가장 끝에 오는 노드
    private int size = 0;   // element 갯수
    privte class Node{      // 객체
        private Object data;
        private Node* next; 
        public Node(Object input*) {
            this.data = input;
            this.next = null;       // 어떤 게 다음 node로 올지 모르므로
        }
        public String toString(){   // data 값을 확인해야 할 때 출력
            return String.valueOf(this.data);
        }
    }
}
```
- *Node: 데이터 저장 + 다음 노드에 대한 정보 저장 (type, 위치 등) => type이 Node
- *input: Node의 값을 주고받을 매개변수

```
☕️ Main.java

package list.linkedlist.implementation;
public class Main {
    public static void main(String[] args){
        LinkedList numbers = new LinkedList();
    }
}
```

### addFirst

```
☕️ Main.java

package list.linkedlist.implementation;
public class Main {
    public static void main(String[] args){
        LinkedList numbers = new LinkedList();
        numbers.addFirst(30);
        numbers.addFirst(20);
        numbers.addFirst(10);      // 후입선출
    }
}
```
```
☕️ LinkedList.java

package list.linkedlist.implementation;
public class LinkedList{
    private Node head;      
    private Node tail;       
    private int size = 0;   
    privte class Node{      
        private Object data;
        private Node* next; 
        public Node(Object input*) {
            this.data = input;
            this.next = null;
        }
        public String toString(){   
            return String.valueOf(this.data);
        }
    }
    public void addFirst(Object input){    // 30, 20, 10
        Node newNode = new Node(input);    
        newNode.next = head;               // node의 정보 ➡️ head, head를 참조해
        head = new Node;                   // 다음 node를 알아낼 수 있음
        size++;
        if(head.next = null){              // 이 Node의 다음 node가 없다면            
            tail = head;                   // 마지막 node는 head와 같다
        }

    }
}
```
<br><br><br>

### addLast
```
☕️ Main.java

package list.linkedlist.implementation;
public class Main {
    public static void main(String[] args){
        LinkedList numbers = new LinkedList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);      // 후입선출
    }
}
```

```
☕️ LinkedList.java

package list.linkedlist.implementation;
public class LinkedList{
    private Node head;      
    private Node tail;       
    private int size = 0;   
    privte class Node{      
        private Object data;
        private Node* next; 
        public Node(Object input*) {
            this.data = input;
            this.next = null;
        }
        public String toString(){   
            return String.valueOf(this.data);
        }
    }
    public void addFirst(Object input){    
        Node newNode = new Node(input);    
        newNode.next = head;               
        head = new Node;                   
        size++;
        if(head.next = null){              
            tail = head;                   
        }

    }

    public void addLast(Object input){
        Node newNode = new Node(input);
        if(size == 0){
            addFirst(input);               // 처음에 들어오는 Node가 되므로
        } else {
            tail.next = newNode;
            tail = newNode;                // 새롭게 들어온 노드가 tail에 위치
            size++;
        }

    }
}
```
- size: 리스트 안에 있는 엘리먼트 갯수
    + size = 0  빈공간이므로 데이터 위치 신경 안 써도 됨
    + size > 0 (데이터 이미 있다)

<br><br><br>

### node(idx)
- 인자값으로 들어온 index의 element를 반환
```
☕️ Main.java

package list.linkedlist.implementation;
public class Main {
    public static void main(String[] args){
        LinkedList numbers = new LinkedList();
        numbers.addLast(10);
        numbers.addLast(20);
        numbers.addLast(30);
        System.out.println(numbers.node(0));    // 0번째 index의 값을 반환
    }
}
``` 
```
☕️ LinkedList.java

package list.linkedlist.implementation;
public class LinkedList{
    /* 생략 */

    public Node node(int index){   // 내부적으로만 사용할 것이기 때문에 
                                   //사실 public은 좋지 않음
        Node x = head;
        return x;

    }
```
- ❗️ 탐색을 위해 list의 가장 첫 node를 찾아야 함 (head)
<br><br>

```
☕️ Main.java


 System.out.println(numbers.node(1));    // 1번째 index의 값을 반환
```
```
☕️ LinkedList.java

    public Node node(int index){   
                                   
        Node x = head;
        x = x.next;
        return x;


```
- 1번째 Node는 0번째 Node 다음에 있음
<br><br>

```
☕️ Main.java


 System.out.println(numbers.node(2));    
```
```
☕️ LinkedList.java

    public Node node(int index){                                      
        Node x = head;
        x = x.next;
        x = x.next
        return x;


```
- 2번째 Node는 1번째 Node 다음에 있음 ➡️ 규칙 有
- index 크기만큼 코드가 반복됨 ➡️ x = x.next를 크기만큼 반복
<br><br><br>

#### 최종
```
☕️ LinkedList.java

    public Node node(int index){                                      
        Node x = head;
        for(int i=0; i < index; i++ ){  // 인덱스 크기만큼 반복
            x = x.next;
        }
        return x;


```
```
☕️ Main.java

 System.out.println(numbers.node(2));

```
```
☕️ console
 30
```
<br><br><br>

### add
- 특정 인덱스에 값을 넣음
<br><br>

```
☕️ Main.java
numbers.addLast(10);
numbers.addLast(20);
numbers.addLast(30);
numbers.add(1, 15);             // index 1에 15를 추가

```
- 20이 뒤로 밀리고 15가 자리를 차지함  

```
☕️ LinkedList.java

    public Node node(int index){                                      
        Node x = head;
        for(int i=0; i < index; i++ ){  // 인덱스 크기만큼 반복
            x = x.next;
        }
        return x;

    public void add(int k, Object input){
        if(k == 0){
            addFirst(input);            // 0이면 가장 처음이므로 addFirst   
        } else {
            Node temp1 = Node(k-1);     // 추가될 노드 앞에 위치할 노드
            Node temp2 = temp1.next;    // 추가될 노드가 가리킬 노드
            Node newNode = new Node(input); // 새로운 노드 생성
            temp1.next = newNode;       // 새로운 노드와 앞 노드 연결
            newNode.next = temp2;       // 새로운 노드가 뒷 노드 가리킴
            size++;                     // size 1 증가
            if(newNode.next == null){   // 추가될 노드가 마지막 노드라면
                tail = newNode;         // 추가될 노드는 tail이 됨
            }
        }
    }
```
- 추가가 잘 됐는지 numbers를 확인하고 싶지만 값은 안 뜨고 엉뚱한 문자열만 뜬다  
  ➡️ toString을 쓰자

<br><br><br>

### toString
- 레퍼런스 말고 데이터의 값을 반환
```
☕️ LinkedList.java

public String toString(){
    if(head == null){           // list가 없다면
        return "[]";
    }
    Node temp = head;
    String str = "[";

    while(temp.next != null){   // 마지막 Node는 다음 Node를 갖지 못하므로
        str += temp.data + ", ";
        temp = temp.next;
    }
    str += temp.data;           // 마지막 data 여기서 삽입
    return str + "]";
}
```
<br><br><br>

### removeFirst
- 첫 인덱스에 있는 값을 제거
```
☕️ Main.java
numbers.addLast(10);
numbers.addLast(20);
numbers.addLast(30);
numbers.removeFirst();          // 10이 없어지고 20, 30 출력           

```
```
☕️ LinkedList.java
public Object removeFirst(){
    Node temp = head;
}
```
- Java에서는 remove 시 삭제된 값을 return 해야 함
<br><br><br>

### remove
```
☕️ Main.java
numbers.addLast(5);
numbers.addLast(10);
numbers.addLast(15);
numbers.addLast(20);
numbers.addLast(30);
System.out.println(numbers.remove(0));     // 5가 삭제되어야 함

```

```
☕️ LinkedList.java
public Object remove(int k){
    if(k == 0){
        return removeFirst();
    }
    Node temp = node(k-1);                 // 지우려는 노드의 앞노드
    Node todoDeleted= temp.next;           // 삭제하려는 노드
    temp.next = temp.next.next;            // 삭제하려는 노드는 링크를 잃게 됨
    Object returnData = todoDeleted.data;

    if(todoDeleted == tail){               // 삭제하려는 값이 마지막 값이라면
        tail = temp;                       // 앞노드를 tail로
    }
    todoDeleted = null;                    // 노드 삭제
    size--;

    return returnData;
}
```
<br><br><br>

### removeLast
```
☕️ Main.java
numbers.addLast(5);
numbers.addLast(10);
numbers.addLast(15);
numbers.addLast(20);
numbers.addLast(30);
System.out.println(numbers.removeLast());     // 5가 삭제되어야 함
```

```
☕️ LinkedList.java
public Object removeLast(){
   return remove(size-1);                      // size-1은 마지막 인덱스값
}
```
